X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(0,N)
Yn <- rep(0,N)
#la fonction pour generer Yn
rYn <- function(Xn)
{
u <- runif(1)
c
}
for(i in 1:n)
{
u <- runif(1)
}
pi
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(0,N)
Yn <- rep(0,N)
#la fonction pour generer Yn
rYn <- function(Xn)
{
u <- runif(1)
c
}
for(i in 1:n)
{
u <- runif(1)
}
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(0,N)
Yn <- rep(0,N)
#la fonction pour generer Yn
rYn <- function(Xn)
{
u <- runif(1)
c
}
for(i in 1:n)
{
u <- runif(1)
}
c <-Q[1,]
c
c[1]
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(0,N)
Yn <- rep(0,N)
#la fonction pour generer Yn
rYn <- function(Xn)
{
Yn <- 1
u <- runif(1)
c <- Q[Xn,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 1:n)
{
u <- runif(1)
}
h = min(1,2)
g
h
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(Xn)
{
Yn <- 1
u <- runif(1)
c <- Q[Xn,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
Yn <- rYn[Xn[i-1]]
h = min(1,(pi[Yn]*Q(Yn,Xn[i-1]))/(pi[X]*Q(Xn[i-1],Yn)))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
Xn[i-1]
rYn[1]
Yn <- 1
u <- runif(1)
c <- Q[Xn,]
c
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
Yn <- rYn[Xn[i-1]]
h = min(1,(pi[Yn]*Q(Yn,Xn[i-1]))/(pi[X]*Q(Xn[i-1],Yn)))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
X<-1
Yn <- 1
u <- runif(1)
c <- Q[X,]
c
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q(Yn,Xn[i-1]))/(pi[X]*Q(Xn[i-1],Yn)))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
Xn
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#step 4, we have now Markov chain Xn ,using the ergodic theorem now
Approx <- mean(Xn^2)
c(1,2,3)
mean(c(1,2,3))
mean(c(1,2,3)^2))
mean(c(1,2,3)^2)
#Step 1 , trouver pi
Q <- t(matrix(data = c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#step 4, we have now Markov chain Xn ,using the ergodic theorem now
Approx <- mean(Xn^2)
#Donc , notre estimation est :
Approx
#Step 1 , trouver pi
Q <- t(matrix(data =c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:1000)
{
pi = pi%*%Q
}
pi = pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#step 4, we have now Markov chain Xn ,using the ergodic theorem now
Approx <- mean(Xn^2)
#Donc , notre estimation est :
Approx
mean(c(1,2,3)^2)Q <- t(matrix(data =c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
Q <- t(matrix(data =c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
#Step 1 , trouver pi
Q <- t(matrix(data =c(0.2,0.1,0.5,0.2,0.1,0.6,0.1,0.2,0.3,0.1,0.2,0.4,0.1,0.1,0.1,0.7),nrow = 4,ncol= 4))
pi = Q
for(i in 1:500)
{
pi <- pi%*%Q
}
pi <- pi[1,]
#Step 2 , set X0
X0 <-1
#Step 3 , built Xn
n = 100000
Xn <- rep(1,N)
Xn[1]<-X0
#la fonction pour generer Yn
rYn <- function(X)
{
Yn <- 1
u <- runif(1)
c <- Q[X,]
if(u <= c[1])
Yn=1
else if(u<=c[2]+c[1])
Yn=2
else if(u<=c[2]+c[1]+c[3])
Yn=3
else
Yn=4
return(Yn)
}
for(i in 2:n)
{
u <- runif(1)
x <- Xn[i-1]
Yn <- rYn(x)
h = min(1,(pi[Yn]*Q[Yn,Xn[i-1]])/(pi[X]*Q[Xn[i-1],Yn]))
if(u < h)
Xn[i]=Yn
else
Xn[i]=Xn[i-1]
}
#step 4, we have now Markov chain Xn ,using the ergodic theorem now
Approx <- mean(Xn^2)
#Donc , notre estimation est :
Approx
